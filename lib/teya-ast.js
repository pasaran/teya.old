var no = require( 'nommon' );

var terror = require( './teya-error.js' );

var BaseAST = require( './ast.js' );
var types = require( './teya-types.js' );
var TYPE = types;

//  ---------------------------------------------------------------------------------------------------------------  //

var AST = function() {};

no.inherit( AST, BaseAST );

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.error = function( id, params ) {
    terror( id, params, this.pos );
};

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.state = {
    tid: 0,
    vid: 0,
    fid: 0,
};

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.cid = 0;
AST.prototype.rid = 0;
AST.prototype.nid = 0;

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.w_def = no.op;
AST.prototype.w_action = no.op;
AST.prototype.w_prepare = no.op;

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype._get_type = function() {
    return TYPE.NONE;
};

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.cast = function( to ) {
    var from = this.get_type();
    to = to || from;
    //  console.log( 'CAST', this.id, from, to );

    if ( !types.is_castable( from, to ) ) {
        this.error( 'CAST_ERROR', {
            from: from,
            to: to
        } );
    }

    if ( from !== to ) {
        this.from_type = from;
        this.to_type = to;
    }

    this.oncast( to );
};

AST.prototype.oncast = no.op;

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.is_inline = no.false;
AST.prototype.is_const = no.false;

//  Метод, который говорит, может ли ast начинаться с атрибута.
//  Например, содержимое тега `<div>` в следующих примерах:
//
//      <div class="hello">
//          //  Точно не начинается с атрибута. Возвращаем `false`.
//          "Hello"
//
//      <div class="hello">
//          //  Точно начинается с атрибута. Возвращаем `true`.
//          @id = "id"
//          "Hello"
//
//      <div class="hello">
//          //  Неизвестно. Возвращаем undefined.
//          ...
//
//  Если мы точно знаем, что атрибутов нет (`false`), то можем выводить предшествующий тег
//  сразу со всеми атрибутами:
//
//      r0 += '<div class="hello">';
//      r0 += 'Hello';
//
//  Иначе нужно сохранять атрибуты в отдельный объект, так что их можно было бы ниже изменить:
//
//      r0 += '<div';
//      a0 = {
//          tag: 'div',
//          attrs: {
//              class: 'hello'
//          }
//      };
//      a0[ 'id' ] = 'id';
//      r0 += close_attrs( a0 );
//      r0 += 'Hello';
//
AST.prototype.starts_with_attr = function() {
    this.error( '%id.starts_with_attr() not implemented', { id: this.id } );
};

//  Метод, который определяет, "закрывает" ли это выражение атрибуты
//  (т.е. после "закрывающего" выражения все конструкции вида `@foo = ...` и другие выражение с типом attr
//  должны игнорироваться, а в поток нужно вывести остатки открывающего тега -- `' class="foo">'`
//  в данном случае).
//
//      <div>
//          @class = "foo"
//          //  Здесь if "закрывает" атрибуты т.к. при любых условиях, его значение будет скалярным.
//          if .foo
//              "Hello"
//          else
//              "Bye"
//          //  Это выражение бесполезно.
//          @data = 42
//
//      <div>
//          @class = "foo"
//          //  Здесь значение метода будет `undefined`. Мы не можем с уверенностью сказать ни да, ни нет.
//          //  Потому что только вторая ветка "закрывает" атрибуты.
//          if .foo
//              @id = "bar"
//          else
//              "Hello"
//          //  Это выражение может повлиять на результат, если `.foo` истинно.
//          @data = 42
//
//      <div>
//          @class = "foo"
//          //  Здесь значение будет (как и в первом примере) `true`.
//          //  Хотя каждая ветка и не начинается со строки, но в каждой ветке присутствует строка.
//          if .foo
//              @id = "bar"
//              "Hello"
//          else
//              @id = "quu"
//              "Bye"
//          //  Это выражение опять таки бесполезно, так как в любом случае `if` "закрывает" атрибуты.
//          @data = 42
//
//      <div>
//          @class = "foo"
//          //  Здесь значение будет `false`, так как тип `if` будет `attr`.
//          if .foo
//              @id = "bar"
//          else
//              @id = "quu"
//          @data = 42
//
//  Возможные значения:
//
//      true        -- "закрывает" точно (например, string).
//      false       -- не "закрывает" точно (например, attr).
//      undefined   -- неизвестно, может так, а может так (например, xml).
//
AST.prototype.closes_attrs = function() {
    this.error( '%id.closes_attrs() not implemented', { id: this.id } );
};

//  Инициирует процесс расстановки `close_attrs` в блоках.
//
AST.prototype.close_attrs = function( is_open ) {
    this.error( '%id.close_attrs() not implemented', { id: this.id } );
};

//  ---------------------------------------------------------------------------------------------------------------  //

AST.prototype.child = function( id, params ) {
    var ast = this.factory.ast( id, this.pos, params );

    ast.parent = this.parent;

    return ast;
};

//  ---------------------------------------------------------------------------------------------------------------  //

module.exports = AST;

//  ---------------------------------------------------------------------------------------------------------------  //

